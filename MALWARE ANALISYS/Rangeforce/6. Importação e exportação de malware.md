---
tags:
  - MALWARE-ANALISYS
  - Rangeforce
---
# Vinculação de bibliotecas
Os ==**arquivos executáveis portáteis (PE)** usam bibliotecas e funções externas para realizar suas operações==. Essas bibliotecas podem ser vinculadas ao executável de algumas maneiras, e o método de vinculação afeta o processo de análise.

## Os métodos incluem:

- **Vinculação estática**: ==Todo o código necessário das bibliotecas é copiado para o executável durante a compilação==. Durante a análise, é difícil diferenciar o código do executável e das bibliotecas. Esse é um método de vinculação incomum em um ambiente Windows.
- **Vinculação dinâmica**: ==As bibliotecas são importadas quando o executável é carregado==. Uma lista de bibliotecas e funções necessárias é adicionada ao cabeçalho do arquivo PE durante a compilação. 
- **Vinculação em tempo de execução**: Comumente usado em executáveis mal-intencionados, especialmente os compactados ou ofuscados. ==Na vinculação em tempo de execução, os executáveis se conectam às bibliotecas e às funções que são chamadas==. Elas não são armazenadas nos cabeçalhos dos arquivos PE. Funções do Microsoft Windows como ``GetProcAddress`` , ``LoadLibrary`` , ``LdrGetProcAddress`` e ``LdrLoadDLL`` facilitam o acesso a qualquer função em qualquer biblioteca do sistema durante o tempo de execução. Se você vir essas funções, espere que o executável use funções adicionais durante o tempo de execução.

---
# Importações e exportações
Bibliotecas e importações

As importações são funções externas usadas pelos executáveis. Elas são armazenadas em bibliotecas vinculadas dinamicamente (DLLs). As bibliotecas exportam funções que os executáveis podem importar, daí o nome. Uma das ferramentas que você pode usar para analisar as importações e exportações é o pestudio, que lista as bibliotecas vinculadas dinamicamente, as importações e as exportações nas respectivas seções. A lista de bibliotecas lhe dará uma ideia geral do que um executável é capaz de fazer, enquanto a lista de importações o ajudará a restringir suas estimativas.

Os executáveis podem importar funções com seus nomes ou ordinais. Os ordinais são números atribuídos às exportações pelas bibliotecas. Os adversários podem usar ordinais em vez de nomes como um meio de ofuscação. O Pestudio geralmente faz um excelente trabalho ao encontrar o nome real da função. Entretanto, se lhe for apresentado um número ordinal dado à biblioteca, você poderá encontrar o nome da função.

O Pestudio inclui uma lista de nomes de funções de importação comumente usadas por malware. Essas funções não são maliciosas por si só, mas são frequentemente usadas por adversários para atividades maliciosas e podem fornecer dicas sobre os recursos da amostra que está sendo analisada. Se você vir uma função desconhecida, não se preocupe - você pode pesquisar na biblioteca da Microsoft Developer Network (MSDN) para obter uma visão geral orientada ao desenvolvedor ou pesquisar no Google por "<função> malware" para obter mais informações no contexto de binários maliciosos.

---
# DLLs comuns
A lista de bibliotecas (DLL) de um executável pode dizer muito sobre seus recursos gerais. A tabela abaixo mostra algumas DLLs comuns usadas com frequência por executáveis mal-intencionados.

| DLL | Description |
| ---- | ---- |
| **Kernel32.dll** | Uma biblioteca comum que contém as principais funcionalidades, como acesso e manipulação de memória, arquivos e hardware. Essa é uma DLL muito comum tanto para software legítimo quanto para malware.<br> |
| **Advapi32.dll** | Significa Advanced Windows 32 Base API e fornece funcionalidade avançada além do Kernel32. Fornece acesso a componentes como Service Manager e Registry (reiniciar/desligar o sistema, iniciar/interromper/criar serviços do Windows, gerenciar contas de usuário etc.). |
| **User32.dll** | Contém componentes para a interface gráfica do usuário, como botões, barras de rolagem, componentes para controlar/responder às ações do usuário etc. Essa DLL pode indicar a existência de uma GUI. |
| **Gdi32.dll	** | Exporta funções de GDI (Graphics Device Interface) usadas para exibir e manipular gráficos. Essa DLL pode indicar a existência de uma GUI. |
| **Ntdll.dll** | Exporta a API nativa do Windows, que é a interface usada pelos componentes do modo de usuário dos sistemas operacionais para executar ações sem a ajuda do Win32 ou de outros subsistemas de API. O Ntdll.dll é carregado diretamente quando a tarefa precisa ser executada durante a inicialização inicial do sistema, antes que o subsistema Win32 esteja disponível. Os executáveis normais não o importam diretamente. Geralmente, ela é importada indiretamente por meio do Kernel32.dll. Se o autor estiver carregando essa DLL diretamente em um executável, você pode estimar que ele pretende usar suas funcionalidades de forma anormal, por exemplo, para executar tarefas como ocultar funcionalidades ou manipular processos. |
| **Wsock32.dll ou Ws2_32.dll** | DLLs responsáveis pela rede. Um executável que se conecta a uma rede ou executa funções relacionadas à rede provavelmente acessará uma dessas DLLs. |
| **Wininet.dll**	 | Contém funções de rede de nível superior que implementam protocolos como FTP, HTTP e NTP. |

Observe que o malware pode carregar bibliotecas adicionais durante o tempo de execução com a ajuda de LoadLibrary e GetProcAddress . Ele pode carregar bibliotecas com a chamada da API LoadLibrary, encontrar o endereço de uma função específica e importá-la. Essas funções não estarão disponíveis na seção de bibliotecas e funções do pestudio.


---
# Funções comuns
Há muitas funções legítimas que os adversários usam para atividades mal-intencionadas. Você deve se ==concentrar no caso de uso e nos recursos da função e não no agrupamento, pois o malware da vida real pode e irá misturá-los==.

Também vale a pena observar algumas convenções de nomenclatura. Você poderá ver os seguintes sufixos nos nomes das funções:

- ==``Ex`` ou `ExEx`==: Quando uma função é atualizada significativamente, a Microsoft continua a oferecer suporte à mais antiga por motivos de compatibilidade. O nome original é mantido para a função original, e o sufixo Ex é adicionado ao nome da nova função para diferenciá-las. O sufixo ExEx indica que essa função foi atualizada significativamente duas vezes.
- ==``A`` e ``W`` ==: Indica que a função usa uma cadeia de caracteres como parâmetro. Ao pesquisar a função no banco de dados da Microsoft, elimine o A ou W final.
	- ==`A`== : Indica que essa é a versão da função que oferece suporte a cadeias de caracteres ASCII.cgnb
	- ==`W`== : Indica que essa é a versão da função que oferece suporte a cadeias de caracteres largas.

## Anti-análise
Alguns exemplos de funções usadas para ==fins de antianálise (antidepuração, detecção de máquinas virtuais e sandboxes, etc.)==:

- **CheckRemoteDebuggerPresent**: Determina se o ==processo especificado== está sendo depurado.
- **CountClipboardFormats**: Retorna o ==número de vários tipos de dados na área de transferência==. Os adversários podem usar essa função para verificar se a área de transferência está vazia ou não.
- **FindWindow**: É usada para ==procurar janelas abertas na área de trabalho==. Pode ser usada para procurar janelas do depurador como um método antidepuração.
- **GetAdaptersInfo**: É usado para ==coletar informações sobre os adaptadores de rede==. Também pode ser usado para coletar informações sobre a máquina infectada ou procurar endereços MAC de ambientes de virtualização conhecidos.
- **GetForeGroundWindow**: Pode ser usado para ==verificar se a cor em primeiro plano está mudando, na esperança de capturar sandboxes automatizadas==.
- **GetProcAddress**: É usado para ==recuperar os endereços das funções das DLLs carregadas==. Semelhante a LoadLibrary e LdrLoadDll, pode ser usado como uma forma furtiva de importar funções. As funções importadas dessa forma não serão armazenadas no cabeçalho do PE.
- **GetTickCount**: Retorna o ==tempo decorrido em milissegundos desde a inicialização do sistema==. Pode ser usado para detectar sandboxes de malware.
- **IsDebuggerPresent**: Uma das técnicas antidepuração mais simples e difundidas. Ela ==detecta se um depurador no modo de usuário está depurando o processo de chamada==.
- **LdrLoadDll**: Uma função de baixo nível ==usada para carregar DLLs em processos em execução (semelhante a LoadLibrary) durante a execução de um processo de depuração==.

## Keyloggers/Spyware
Alguns exemplos de funções usadas por **keyloggers** e **spyware**:

- **AttachThreadInput**: ==Anexa o processamento de entrada de um thread a outro==. Isso permite que o segundo thread receba *entradas como teclado e mouse*. Keyloggers e spywares podem usá-lo.
- **GetAsyncKeyState**: É usado para ==verificar se uma tecla específica está sendo pressionada==. Os keyloggers às vezes o utilizam.
- **GetDC**: pode ser usado por spyware para ==fazer capturas de tela de janelas específicas ou da tela inteira==.
- **GetForegroundWindow**: ==Recupera um identificador para a janela atualmente em primeiro plano==. Os keyloggers podem usá-lo para determinar em qual janela o usuário está digitando as teclas no momento.
- **GetKeyState**: Os keyloggers podem usá-lo para ==determinar se uma tecla específica está sendo pressionada==.
- **LsaEnumerateLogonSessions**: ==Enumera as sessões de logon==. Pode ser usado por ladrões de credenciais.
- **MapVirtualKey**: ==Traduz o código da chave virtual em valores de caracteres==. Os keyloggers podem usá-lo.
- **RegisterHotKey**: Pode ser ==usado para informar ao malware se uma combinação específica de teclas for pressionada==. São usados por spywares para se revelarem à pessoa autorizada.
- **SamIConnect, SamIGetPrivateData, SamQueryInformationUse**: Conecta-se ao SAM (Security Account Manager). Pode ser ==usado para despejar hashes de login e senha do usuário==.
- **SetWindowsHookEx**: Comumente usado por spyware. Essa função é ==uma das formas mais comuns de os keyloggers receberem entradas do teclado==.

## Rede
Alguns exemplos de funções usadas pelo malware para **comunicações de rede**:

- **Accept**: ==Usada para escutar as conexões de entrada em um socket==.
- **Bind** (vincular): Associa um endereço local a um socket para ==ouvir as conexões de entrada==.
- **Connect**: É usado para se ==conectar a um socket remoto==. Pode ser usado por malware para se conectar a servidores de comando e controle.
- **FtpPutFile**: pode ser ==usado para carregar um arquivo em um servidor FTP remoto==.
- **Gethostbyname**: pode ser ==usado para fazer uma pesquisa de DNS em um nome de host antes de iniciar uma conexão IP com um servidor.==
- **inet_addr**: ==converte cadeias de endereços IP para serem usadas por funções como connect==.
- **InternetOpen**: inicializa as ==funções de acesso de alto nível à Internet==.
- **InternetOpenUrl**: ==Abre uma URL específica para conexão==.
- **InternetReadFile**: ==Lê dados de uma URL já aberta==.
- **InternetWriteFile**: ==grava dados em uma URL já aberta==.
- **NetShareEnum**: ==Enumera os compartilhamentos de rede==.
- **Recv**: ==Recebe dados de um sistema remoto==. Pode ser usado para receber dados de servidores de comando e controle.
- **Send**: ==Envia dados para um sistema remoto==. Pode ser usado para enviar dados a servidores de comando e controle.
- **URLDownloadToFile**: pode ser ==usado para fazer download e salvar um arquivo de um servidor da Web==. Geralmente usado por downloaders.

## Manipulação de processos/memória/privilégios
Alguns exemplos de funções usadas por malware para **manipulação de processos**, **memória** e/ou **privilégios**:

- **AdjustTokenPrivileges**: Frequentemente ==usado por malware de injeção de processos para obter privilégios adicionais==. Pode ser usado para ativar/desativar privilégios de acesso.
- **CreateProcess**: Pode ser usado para criar e iniciar um novo processo.
- **CreateFileMapping**: É usado para carregar um arquivo na memória e torná-lo acessível por meio de endereços de memória. Lançadores, carregadores e injetores usam isso para ler e modificar arquivos PE.
- **CreateRemoteThread**: Pode ser usado para iniciar um thread em um processo remoto, usado por lançadores e injetores para injetar código em processos remotos.
- **CreateToolhelp32Snapshot**: O malware pode usar isso para iterar por processos ou threads. Ele cria instantâneos de processos, threads e módulos.
- **EnumProcesses**: Enumera os processos em execução. Os injetores usam isso para encontrar um processo no qual injetar.
- **EnumProcessModules**: Enumera os módulos carregados (DLLs e executáveis) de um determinado processo. A enumeração é feita durante a injeção.
- **GetModuleFilename**: Retorna o nome do arquivo do módulo carregado no processo, usado pelo malware para copiar ou modificar arquivos nos processos em execução.
- **GetModuleHandle**: Obtém um identificador para um módulo carregado. Pode ser usado para modificar o código em um módulo carregado ou procurar um local para injetar código.
- **IsNTAdmin**: Verifica se o usuário atual tem privilégios administrativos.
- **NtSetInformationProcess**: Pode ser usado para ajustar os níveis de privilégio dos programas.
- **MapViewOfFile**: mapeia um arquivo na memória e torna seu conteúdo acessível por meio de endereços de memória. Lançadores, carregadores e injetores podem usá-lo para ler e modificar arquivos PE.
- **OpenProcess**: Abre um identificador para outro processo em execução. Pode ser usado para ler e gravar na memória de outro processo, incluindo injeção de código.
- **ReadProcessMemory** e Toolhelp32ReadProcessMemory: É usado para ler a memória de um processo remoto.
- **VirtualAllocEx**: pode alocar memória em um processo remoto. Pode ser usado como parte da injeção de processo.
- **VirtualProtectEx**: ajusta a proteção em uma região da memória. Pode ser usado por malware para alterar a seção somente leitura da memória para executável.
- **WriteProcessMemory**: Pode ser usado como parte da injeção de processo para gravar dados em um processo remoto.

## Modificação do registro
Alguns exemplos de funções usadas por malware para modificações no registro:

- **GetThreadContext**: Pode ser usado para obter informações sobre um determinado thread, como valores de registro.
- **RegOpenKey**: Pode ser usada para ler e editar chaves de registro. Às vezes usado por malware para obter persistência ou ler informações sobre o sistema.
- **RegCloseKey**: É usado para fechar um identificador da chave de registro especificada.
- **RegCreateKey**: É usado para criar a chave de registro especificada (abre-a se existir).
- **RegEnumValue**: Usado para enumerar a chave do Registro já aberta.
- **RegDeleteValue**: Usado para remover um valor nomeado da chave do registro.
- **RegQueryInfoKey**: Usado para recuperar informações sobre uma chave do Registro.
- **RtlCreateRegistryKey**: Usado para criar um registro a partir do código do modo kernel.
- **RtlWriteRegistryValue**: Usado para gravar um valor no registro a partir do código do modo kernel.

## Arquivo e diretório
Alguns exemplos de funções usadas pelo malware para manipulação de arquivos e diretórios:

- **CreateFile**: cria um novo arquivo ou o abre se ele já existir.
- **DeleteFile**: marca um arquivo para ser excluído ao ser fechado.
- **CreateFileMapping**: Pode ser usado para carregar um arquivo em uma memória que pode ser acessada por meio de um endereço de memória. Lançadores, carregadores e injetores podem usá-lo para ler e modificar arquivos PE.
- **FindFirstFile** e **FindNextFile**: podem ser usados para pesquisar em um diretório e enumerar o sistema de arquivos.
- **GetTempPath**: Retorna o caminho do arquivo temporário. Verifique a amostra para ver se ela lê/grava arquivos no caminho do arquivo temporário.
- **GetWindowsDirectory**: Retorna o caminho para o diretório do Windows. Pode ser usado por malware para determinar onde instalar software malicioso adicional.
- **MapViewOfFile**: semelhante ao CreateFileMapping. Além disso, permite evitar o WriteFile para modificar o conteúdo de um arquivo.
- **NtQueryDirectoryFile**: recupera informações sobre arquivos em um diretório. Os rootkits podem usá-lo para ocultar arquivos.
- **ReadFile/WriteFile**: lê/grava dados de/em um arquivo ou dispositivo de E/S.
- **SetFileTime**: pode alterar a hora de criação, acesso ou modificação de um arquivo. São usados pelo malware para ocultar suas atividades maliciosas.
- **SfcTerminateWatcherThread**: Pode ser usado para desativar a proteção de arquivos do Windows para modificar arquivos protegidos.

